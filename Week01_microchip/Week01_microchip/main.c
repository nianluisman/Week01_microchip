/*
 * Week01_microchip.c
 *
 * Created: 15-2-2022 16:04:08
 * Author : nianl
 */ 

#include <util/delay.h>
#include <avr/io.h> // Include the 'avr/io' header file, to use the facilities provided by this header file.
#include <avr/interrupt.h> // Include the 'avr/interrupt' header file, to use the facilities provided by this header file.
#include <stdbool.h> // Include the 'stdbool' header file, to use the facilities provided by this header file.
// The main function of your program.

#define F_CPU (16000000UL) // Here the frequency of the micro controller is defined as unsigned long (the frequency of the ATmega328 is 16 MHz).
#define BAUD (9600) // The BAUD-rate used for the USART communication.
#define BRC ((F_CPU / 16UL / BAUD) - 1) // Calculate the value for the UBRR0 registers. You are calculating this at compile-time, that saves resources.
#define TX_BUFFER_size 128

char serialbufffer [TX_BUFFER_size];
uint8_t serialReadPos = 0;
uint8_t serialWritePos = 0;

char string[TX_BUFFER_size]; 

#define MASK_MSB 0b11110000 // This is your bit mask this will be applied on the value of the ADCH register.
#define NIBBLE 4

void appendSerial(char c );
void serialWrite(char c[]);
int value = 0;

int main(void)
{
	//*************************This is the setup of the USART**********************************************************
	UBRR0H = (BRC >> 8); // This is the USART BAUD generator register. Write the last bits of the value of 'BRC' to this 'UBRR0H' register. In this case 'BRC' is the value required for the BAUD-generator.
	UBRR0L = BRC; // This is also the USART BAUD generator register. Write the value of the 'BRC' to this 'UBRR0L' register.
	
	UCSR0B = (1 << TXEN0) |  (1 << TXCIE0) | (1 << RXEN0) | (1 << RXCIE0); // Here, you enable the TX and the RX for the USART communication. Also, you enable the interrupt generated by a complete conversion of your RX. Also enable TX with her specified interrupt.
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // Here, you are using 8-bits data (the 'UCSZ00' bit), and in total 2 stop bits (the 'USBS0' bit).
	


	// *************************This is the setup of the ADC******************************
	// This is done by clearing the global interrupt flag in the SREG register by calling this function 'cli()'.
	DDRB |= (1 << PINB0) | (1 << PINB1) | (1 << PINB2) | (1 << PINB3); // Set the pins 'PB3', 'PB2', 'PB1' and 'PB0' as an output.
	DIDR0 |= (1 << ADC0D); // Here you have to disable the digital input of a specific pin to use it as an ADC. In this case, the digital input op 'ADC0D' is disabled.
	ADMUX |= (1 << REFS0) | (1 << ADLAR); // This is the ADC Multiplexer Selection register. Here you can enable the right multiplexer of the ADC. We are using ADC0.
	// We are also using the internal voltage reference (AVcc) i
	
	// The ADLAR (ADC Left Adjust Result) bit is written to one. The ADLAR bit affects the presentation of the ADC conversion result in the ADC Data Register.
	// Write one to ADLAR to left adjust the result. Otherwise, the result is right adjusted.
	// Because we are storing a 10-bits result in 8-bits register, we have to use two register. The ADCH and ADCL register. Now the result is right aligned.
	ADCSRA |= (1 << ADEN) | (1 << ADATE) | (1 << ADIE) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // This is the ADC Status and Control Register A. Here you enable the ADC by writing a '1' to the ADEN bit.
	// We are also using an interrupt that will be fired when a conversion in complete.
	// In order to retrieve the right speed of the ADC (125 KHz), we are using a prescaler of '128'.
	// Here the free running mode of the ADC is also enabled. This is by writing the 'ADIE' bit.
	// Pay attention! When writing this bit to one, you have to select its mode in the 'ADCSRB' register.
	ADCSRB |= (0 << ADPS2) | (0 << ADPS1) | (0 << ADPS0); // Here the ADC is in free running mode (see the corresponding table in the data sheet). You can also write 'ADCRSB = 0b0', but this is much clearer to me.
	sei(); // This statement enables all interrupts. You're setting the global interrupt flag.
	// This allows you to use the interrupts to interrupt your code. In order to properly complete their own 'interrupt service routine'.
	// This is done by setting the global interrupt flag in the SREG register by calling this function 'sei()'.
	ADCSRA |= (1 << ADSC); // Start your first conversion. After this, the ADC will keep running automatically.
	// This is your while loop (infinite loop).
	
	sei();
	UDR0 = 0;
	serialWrite("Welkom to me test project \r\n");//too welkom the user 
	_delay_ms(1500);
		serialWrite("The value of the adc is:\r\n"); //to inform the user what there looking at
		_delay_ms(1500);
		
	while (true)
	{
		_delay_ms(2500);
		serialWrite(string); //the value of de adc		
	} 
}
 


 void appendSerial(char c){//read out string one char at the time 
	serialbufffer[serialWritePos] = c;
	serialWritePos++;
	
	if(serialWritePos >= TX_BUFFER_size){
		serialWritePos = 0;
	}
}
void serialWrite(char c[]){ //get string in to buffer 
	for(uint8_t i = 0; i < strlen(c); i++){
		appendSerial(c[i]);
	}
	if(UCSR0A & (1 << UDRE0)){
		UDR0 = 0;
	}
}
ISR(USART_TX_vect) // You can also use USART_UDRE_vect, but you have to set the correct bit in the USCR0B register.
{
	_delay_ms(500);
	if(serialReadPos != serialWritePos){
		UDR0 = serialbufffer[serialReadPos];// Write the 'analog_value' to your 'UDR0'-register to send new data through the USART.
		serialReadPos++;
		if (serialReadPos >= TX_BUFFER_size)
		{
			serialReadPos = 0;
		}
	}
}

ISR(USART_RX_vect){
			PORTB = UDR0;		
		UCSR0A = (1	<< TXC0); 
}
ISR(ADC_vect)
{
	//PORTB = ((MASK_MSB & ADCH) >> NIBBLE); // Read the ADCH register. In the left nibble contains your MSB values. Apply a bit-mask, and shift the result to the right. Then you can display the results on your LEDs.
	sprintf(string, "%d", ((MASK_MSB & ADCH) >> NIBBLE));//put value of PORTB as a string so print out on the monitor
}